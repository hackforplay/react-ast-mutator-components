import * as t from '@babel/types';
import { NodeProps as P } from './types';
export declare function Expression<T extends t.Expression>(props: P<T>): any;
export declare function Binary<T extends t.Binary>(props: P<T>): any;
export declare function Scopable<T extends t.Scopable>(props: P<T>): any;
export declare function BlockParent<T extends t.BlockParent>(props: P<T>): any;
export declare function Block<T extends t.Block>(props: P<T>): any;
export declare function Statement<T extends t.Statement>(props: P<T>): any;
export declare function Terminatorless<T extends t.Terminatorless>(props: P<T>): any;
export declare function CompletionStatement<T extends t.CompletionStatement>(props: P<T>): any;
export declare function Conditional<T extends t.Conditional>(props: P<T>): any;
export declare function Loop<T extends t.Loop>(props: P<T>): any;
export declare function While<T extends t.While>(props: P<T>): any;
export declare function ExpressionWrapper<T extends t.ExpressionWrapper>(props: P<T>): any;
export declare function For<T extends t.For>(props: P<T>): any;
export declare function ForXStatement<T extends t.ForXStatement>(props: P<T>): any;
export declare function Function<T extends t.Function>(props: P<T>): any;
export declare function FunctionParent<T extends t.FunctionParent>(props: P<T>): any;
export declare function Pureish<T extends t.Pureish>(props: P<T>): any;
export declare function Declaration<T extends t.Declaration>(props: P<T>): any;
export declare function PatternLike<T extends t.PatternLike>(props: P<T>): any;
export declare function LVal<T extends t.LVal>(props: P<T>): any;
export declare function TSEntityName<T extends t.TSEntityName>(props: P<T>): any;
export declare function Literal<T extends t.Literal>(props: P<T>): any;
export declare function Immutable<T extends t.Immutable>(props: P<T>): any;
export declare function UserWhitespacable<T extends t.UserWhitespacable>(props: P<T>): any;
export declare function Method<T extends t.Method>(props: P<T>): any;
export declare function ObjectMember<T extends t.ObjectMember>(props: P<T>): any;
export declare function Property<T extends t.Property>(props: P<T>): any;
export declare function UnaryLike<T extends t.UnaryLike>(props: P<T>): any;
export declare function Pattern<T extends t.Pattern>(props: P<T>): any;
export declare function Class<T extends t.Class>(props: P<T>): any;
export declare function ModuleDeclaration<T extends t.ModuleDeclaration>(props: P<T>): any;
export declare function ExportDeclaration<T extends t.ExportDeclaration>(props: P<T>): any;
export declare function ModuleSpecifier<T extends t.ModuleSpecifier>(props: P<T>): any;
export declare function Flow<T extends t.Flow>(props: P<T>): any;
export declare function FlowType<T extends t.FlowType>(props: P<T>): any;
export declare function FlowBaseAnnotation<T extends t.FlowBaseAnnotation>(props: P<T>): any;
export declare function FlowDeclaration<T extends t.FlowDeclaration>(props: P<T>): any;
export declare function FlowPredicate<T extends t.FlowPredicate>(props: P<T>): any;
export declare function JSX<T extends t.JSX>(props: P<T>): any;
export declare function Private<T extends t.Private>(props: P<T>): any;
export declare function TSTypeElement<T extends t.TSTypeElement>(props: P<T>): any;
export declare function TSType<T extends t.TSType>(props: P<T>): any;
//# sourceMappingURL=Aliases.d.ts.map